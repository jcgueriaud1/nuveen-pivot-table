package org.vaadin.example.pivot.datasource;

import com.vaadin.flow.component.grid.Grid;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Converts a list of bean to a pivot data.
 *
 * @author Martin Vysny <mavi@vaadin.com>
 */
public interface PivotDataSource<T> extends Serializable {

    final class Row<T> implements Serializable {
        @NotNull
        private final Map<String, Object> values;

        /**
         * The list of beans, aggregated together to produce this row. Non-null
         * for {@link InMemoryPivot} only - when the calculation is performed
         * remotely (e.g. in SQL) then it's not possible to retrieve the beans
         * and this is null.
         * <p></p>
         * Only for the internal purpose of {@link ColumnGroupingPivotDataSource}
         * in order to calculate grand totals.
         */
        @Nullable
        final List<T> sourceBeans;

        public Row(@NotNull Map<String, Object> values, @Nullable List<T> sourceBeans) {
            this.values = values;
            this.sourceBeans = sourceBeans;
        }

        /**
         * Retrieves the value for given id.
         *
         * @param id ID as registered via <code>groupBy</code>/<code>aggregates</code>
         *           parameters passed to {@link PivotDataSource#computePivotRows(LinkedHashSet, LinkedHashSet, Set, List, PivotFilter)}.
         * @return the value or null for non-existing ID.
         */
        @Nullable
        public Object get(@NotNull String id) {
            return values.get(id);
        }

        /**
         * Retrieves the value for given id.
         *
         * @param column the column from {@link PivotResult#columns}.
         * @return the value or null if the value is missing for this particular cell.
         */
        @Nullable
        public Object get(@NotNull PivotColumn<?> column) {
            return get(column.id);
        }

        public void put(String id, Object value) {
            values.put(id, value);
        }

        @Nullable
        public List<T> getSourceBeans() {
            return sourceBeans;
        }

        @Override
        @NotNull
        public String toString() {
            return "Row{" + values + '}';
        }

        @NotNull
        public Map<String, Object> getValues() {
            return values;
        }
    }

    /**
     * Groups given items according to the current grouping spec as specified via
     * <code>groupBy</code>; then performs aggregating as specified via the <code>aggregate</code>
     * parameter.
     *
     * @param groupBy       Groups the data by a value produced by the <code>groupedValue</code> closure.
     *                      Maps an ID to the grouping specifier. All rows for
     *                      a particular value computed by this closure are grouped together.
     *                      The grouping value will be accessible via the {@link Row#get(String)} by supplying the ID.
     * @param aggregates    Aggregate the grouped data. Maps an ID to the aggregate specifier.
     *                      The aggregate value will be accessible via the {@link Row#get(String)} by supplying the ID.
     * @param grandTotalIDs Compute grand totals for <code>aggregates</code> with these IDs.
     *                      The aggregate value will be accessible via the {@link PivotResult#grandTotalValues}
     *                      by supplying the ID as the key.
     * @param items         the items to process, not null, may be empty.
     * @param filters
     * @return a list of grouped and aggregated rows, not null, may be empty.
     */
    @NotNull
    PivotResult<T> computePivotRows(
            @NotNull LinkedHashSet<GroupBy<T>> groupBy,
            @NotNull LinkedHashSet<Aggregate<T>> aggregates,
            @NotNull Set<String> grandTotalIDs,
            @NotNull List<T> items,
            @NotNull PivotFilter filters
    );

    final class PivotColumn<T> implements Serializable {
        /**
         * The column ID, passable into {@link Row#get(String)} and {@link PivotResult#grandTotalValues}.
         */
        @NotNull
        public final String id;

        /**
         * When using column grouping, this will be the value of the group.
         */
        @Nullable
        public final Object columnGroupValue;
        /**
         * If not null, the value of this column has been generated by this aggregate function.
         */
        @Nullable
        public final Aggregate<T> aggregate;

        /**
         * If not null, the value of this column has been generated by the grouping function with this id.
         * This is null for an aggregate column.
         */
        @Nullable
        public final GroupBy<T> groupBy;

        public PivotColumn(
                @NotNull String id,
                @Nullable Object columnGroupValue,
                @Nullable Aggregate<T> aggregate,
                @Nullable GroupBy<T> groupBy
        ) {
            this.columnGroupValue = columnGroupValue;
            this.aggregate = aggregate;
            this.groupBy = groupBy;
            if (aggregate == null) {
                Objects.requireNonNull(groupBy);
            }
            this.id = Objects.requireNonNull(id);
        }

        @Override
        public String toString() {
            return "PivotColumn{" +
                    "id='" + id + '\'' +
                    ", columnGroupValue=" + columnGroupValue +
                    ", aggregate=" + aggregate +
                    ", groupBy=" + groupBy +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PivotColumn<?> that = (PivotColumn<?>) o;
            return id.equals(that.id);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }

        /**
         *
         * @return true if it's a top group
         */
        public boolean isColumnGroup() {
            return columnGroupValue != null;
        }

        public boolean isRowGroup() {
            return (groupBy != null) && !isColumnGroup();
        }

        public boolean isAggregate() {
            return (aggregate != null);
        }

        @NotNull
        public String getCaption() {
            String caption;
            if (aggregate != null) {
                caption = aggregate.getCaption();
            } else {
                caption = groupBy.getCaption();
            }
            return caption;
        }

        /**
         * Indicates, if filtering is enabled for this column. If true, the column will show a filter field.
         * @return filtering is enabled
         */
        public boolean isFilterEnabled() {
            if (groupBy != null) {
                return groupBy.isFilterEnabled();
            }

            return aggregate != null && aggregate.isFilterEnabled();
        }
    }

    /**
     * Holds an ordered list of {@link #columns} and the list of result rows.
     *
     * @param <T> the input bean type.
     */
    final class PivotResult<T> implements Serializable {
        /**
         * The list of data to populate the grid with. May be empty.
         */
        @NotNull
        public final List<Row<T>> rows;

        private GroupBy<T> topGroup;

        /**
         * Lists all columns.
         * Follows the order of <code>groupBy</code> and <code>aggregate</code> parameters
         * passed to {@link PivotDataSource#computePivotRows(LinkedHashSet, LinkedHashSet, Set, List, PivotFilter)}.
         */
        @NotNull
        public final List<PivotColumn<T>> columns;

        /**
         * Maps an ID to the "Grand Total" value for that particular column.
         */
        @NotNull
        public final Map<String, Object> grandTotalValues;

        public PivotResult(
                @NotNull List<Row<T>> rows,
                @NotNull List<PivotColumn<T>> columns,
                @NotNull Map<String, Object> grandTotalValues) {
            this.rows = Objects.requireNonNull(rows);
            this.columns = Objects.requireNonNull(columns);
            this.grandTotalValues = Objects.requireNonNull(grandTotalValues);
        }

        /**
         * Returns true if the {@link PivotDataSource} grouped the data also by columns.
         */
        public boolean hasColumnGrouping() {
            return columns.stream().anyMatch(it -> it.isColumnGroup());
        }

        /**
         * True if there are any final grand totals to display in the Grid footer.
         */
        public boolean hasGrandTotals() {
            return !grandTotalValues.isEmpty();
        }

        /**
         * Returns a list of column IDs.
         *
         * @return a list of column IDs, not null, may be empty.
         */
        @NotNull
        public List<String> getColumnIds() {
            return columns.stream().map(it -> it.id).collect(Collectors.toList());
        }

        @NotNull
        public PivotColumn<T> getColumn(@NotNull String id) {
            final PivotColumn<T> col = columns.stream().filter(it -> it.id.equals(id)).findAny().orElse(null);
            Objects.requireNonNull(col, () -> "No column with id " + id + ". Available columns: " + columns.stream().map(it -> it.id).collect(Collectors.joining(", ")));
            return col;
        }

        @Nullable
        public Object getGrandTotal(@NotNull PivotColumn<T> column) {
            return grandTotalValues.get(column.id);
        }

        /**
         * Indicates, if there is at least one column with filtering enabled.
         * @return at least one column is enabled
         */
        public boolean hasEnabledFilters() {
            return columns.stream().anyMatch(PivotColumn::isFilterEnabled);
        }

        public GroupBy<T> getTopGroup() {
            return topGroup;
        }

        public void setTopGroup(GroupBy<T> topGroup) {
            this.topGroup = topGroup;
        }
    }

    /**
     * A simple type containing filter information set by the user.
     */
    final class PivotFilter implements Serializable {
        private final Map<String, Set<Object>> filterValues = new HashMap<>();

        /**
         * Return a map with set filter values. The map key represents the column key, that can be obtained by
         * {@link Grid.Column#getKey()} or pivot internal elements, like {@link Aggregate#id}. The value type
         * depends on the filter field (e.g. String, Integer, etc.).
         * <p/>
         * Returns always a map, never null.
         * @return filter values map.
         */
        public Map<String, Set<Object>> getFilterValues() {
            return filterValues;
        }

        /**
         * Indicates, if there are any values set. Basically returns {@link Map#isEmpty()}.
         * @return filter is empty
         */
        public boolean isEmpty() {
            return filterValues.isEmpty();
        }
    }
}
